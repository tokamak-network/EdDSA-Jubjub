# EdDSA-JubJub and Poseidon Hash

This repository contains implementations of the EdDSA signature scheme over the JubJub curve and the Poseidon hash function, in both Rust and TypeScript. The project is structured as a monorepo with two main packages: `rust` and `typescript`.

## Project Structure

The project is organized into a `packages` directory, which contains the two main implementations:

-   **`packages/rust`**: A Cargo workspace containing the Rust implementation of the EdDSA-JubJub signature scheme and the Poseidon hash function.
-   **`packages/typescript`**: A TypeScript project that mirrors the functionality of the Rust crates, intended for testing, interoperability, and client-side applications.

## `packages/rust`

This is a Cargo workspace containing two crates: `eddsa` and `poseidon2`. It is built on top of the [arkworks](https://arkworks.rs/) ecosystem, which provides a comprehensive suite of tools for building and working with zero-knowledge proof systems.

### `eddsa` Crate

This crate provides a full implementation of the EdDSA signature scheme tailored for the JubJub curve.

#### The JubJub Curve

JubJub is an embedded elliptic curve defined over the BLS12-381 scalar field. This construction is highly efficient for use inside zero-knowledge proofs. A key characteristic of JubJub is its **cofactor of 8**. This means the total number of points on the curve is `8 * n`, where `n` is the order of the prime-order subgroup used for cryptography. This cofactor necessitates careful handling during signature verification to prevent attacks.

#### EdDSA Signing and Verification

The EdDSA implementation follows the standards set in RFC 8032 but is adapted for the JubJub curve and uses Poseidon as the hash function.

**Signing Process:**

1.  **Key Expansion**: The 32-byte private key is hashed using BLAKE3 to produce a 64-byte expanded key. The lower 32 bytes are used to derive the scalar signing key `sk`, and the upper 32 bytes are used for nonce generation.
2.  **Deterministic Nonce**: A deterministic nonce `r` is generated by hashing the private key and the message. This is a critical security feature that prevents key leakage through nonce reuse.
3.  **Challenge Calculation**: The challenge `c` is computed by hashing the public nonce point `R`, the public key `Pk`, and the message `M` using the Poseidon hash: `c = H(R, Pk, M)`.
4.  **Signature Scalar**: The final signature scalar `s` is calculated as `s = r + c * sk`. The signature is the pair `(R, s)`.

**Challenge Calculation in Detail:**

The challenge `c` is a crucial part of the signature, as it binds the nonce, the public key, and the message together. Here's how it's calculated:

1.  **Data Preparation**: The x and y coordinates of the public nonce point `R` and the public key `Pk`, along with the message `M`, are serialized into byte arrays. **Crucially, these are serialized in Big-Endian byte order**, as expected by the Poseidon hash implementation.
2.  **Concatenation**: The byte arrays are concatenated in a specific order: `R.x || R.y || Pk.x || Pk.y || M`.
3.  **Hashing**: The concatenated byte array is then fed into the `poseidon_btree_hasher` function.
4.  **Conversion**: The resulting 32-byte hash output (which is a base field element) is then converted into a scalar field element to be used in the signature equation.

Here is a visual representation of the process:

```
+-----------------+   +-----------------+   +-----------------+   +-----------------+   +-----------------+
| R.x (32 bytes)  |   | R.y (32 bytes)  |   | Pk.x (32 bytes) |   | Pk.y (32 bytes) |   | M (32 bytes)    |
| (Big-Endian)    |   | (Big-Endian)    |   | (Big-Endian)    |   | (Big-Endian)    |   | (Big-Endian)    |
+-----------------+   +-----------------+   +-----------------+   +-----------------+   +-----------------+
        |                   |                   |                   |                   |
        +-------------------+-------------------+-------------------+-------------------+
                                      |
                              Concatenated Bytes (160 bytes)
                                      |
                                      v
                          +-------------------------+
                          | poseidon_btree_hasher  |
                          +-------------------------+
                                      |
                                      v
                            +-------------------+
                            |  c (32-byte hash) |
                            +-------------------+
```

**Verification Process:**

The verification process is designed to be secure on a curve with a cofactor.

1.  **Range Check**: The verifier first checks that the signature scalar `s` is within the valid range `[0, n-1]`.
2.  **Cofactored Verification**: Instead of checking the standard EdDSA equation `s * G == R + c * Pk`, this implementation uses **cofactored verification**. Both sides of the equation are multiplied by the cofactor (8), resulting in the check: `8 * s * G == 8 * R + 8 * c * Pk`. This algebraically eliminates any small-subgroup components from the public key or nonce point, preventing attacks that could otherwise lead to signature forgery.

### Usage

Here is a quick example of how to use the `eddsa` crate for key generation, signing, and verification.

```rust
use eddsa::{EdDSAPrivateKey, EdDSAPublicKey, EdDSASignature};
use rand::thread_rng;

fn main() {
    let mut rng = thread_rng();

    // 1. Generate a random private key
    let sk = EdDSAPrivateKey::random(&mut rng);

    // 2. Derive the public key
    let pk = sk.public();

    // 3. Sign a message (byte slice)
    let message = b"Hello, JubJub!";
    let signature = sk.sign_bytes(message);

    // 4. Verify the signature
    let is_valid = pk.verify(message, &signature);
    assert!(is_valid);

    // 5. Serialization & Deserialization
    
    // Public Key
    let pk_bytes = pk.to_compressed_bytes().expect("Failed to serialize PK");
    let pk_decoded = EdDSAPublicKey::from_compressed_bytes(&pk_bytes).expect("Failed to deserialize PK");
    assert_eq!(pk, pk_decoded);

    // Signature
    let sig_bytes = signature.to_compressed_bytes().expect("Failed to serialize Sig");
    let sig_decoded = EdDSASignature::from_compressed_bytes(&sig_bytes).expect("Failed to deserialize Sig");
    assert_eq!(signature, sig_decoded);
}
```

### `poseidon2` Crate

This crate implements the Poseidon hash function, which is optimized for zero-knowledge proof systems. All hashing operations are performed over the BLS12-381 scalar field, which is a critical requirement for the security of the EdDSA-JubJub scheme.

#### Poseidon B-Tree Hasher

The `poseidon_btree_hasher` function provides a way to hash inputs of arbitrary length into a single 32-byte root, structured like a B-tree.

**Parameters and Invocation:**

*   **Input**: The function takes a single parameter: a byte slice `&[u8]` of any length.
*   **Invocation**: `poseidon_btree_hasher(my_byte_slice)`
*   **Output**: It returns a `Result<Vec<u8>, String>`, which on success contains a 32-byte `Vec<u8>` representing the root of the tree.

**Process:**

1.  **Chunking**: The input byte slice is divided into 32-byte chunks. Each chunk is interpreted as a field element.
2.  **Padding**: If the input is not a multiple of 32 bytes, the final chunk is padded with zeros. If the total number of chunks is not a power of two, additional zero chunks are added to balance the tree.
3.  **Recursive Hashing**: The chunks are recursively hashed in pairs using the 2-input Poseidon hash function (`poseidon2`). This process is repeated until a single hash output remains. This final hash is the root of the B-tree.

**Visual Example of Recursive Hashing:**

Here is a visual representation of how four chunks (C1, C2, C3, C4) are hashed into a single root:

```
             Root
               ^
               |
         H(H12, H34)
         /         \
        /           \
      H12           H34
      / \           / \
     /   \         /   \
   H(C1,C2)     H(C3,C4)
   /     \       /     \
  C1     C2     C3     C4
```

If the number of chunks is not a power of two, the tree is balanced by hashing a chunk with a zero-padded chunk.

## `packages/typescript`

This directory contains a TypeScript implementation of the same cryptographic primitives found in the Rust crates. This is useful for:

*   **Testing**: Verifying the correctness of the Rust implementation against a well-known JavaScript library (`@noble/curves`).
*   **Interoperability**: Providing a JavaScript/TypeScript interface for the same cryptographic functions.
*   **Web-based Applications**: Using the cryptography in a browser or Node.js environment.

The scripts use the following npm packages:

*   **[@noble/curves](https://www.npmjs.com/package/@noble/curves)**: For elliptic curve operations on the JubJub curve.
*   **[poseidon-bls12381](https://www.npmjs.com/package/poseidon-bls12381)**: For the Poseidon hash function over the BLS12-381 scalar field.

## Building and Testing

### Rust

To build the Rust crates, navigate to the `packages/rust` directory and run:

```bash
cargo build
```

To run the tests for all crates in the workspace:

```bash
cargo test
```

### TypeScript

To run the TypeScript tests, first navigate to the `packages/typescript` directory and install the dependencies:

```bash
cd packages/typescript
npm install
```

Then, run the tests:

```bash
npm test
```
